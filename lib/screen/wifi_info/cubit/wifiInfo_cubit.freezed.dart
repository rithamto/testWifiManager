// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'wifiInfo_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$WifiInfoStateData {
  String get ssid => throw _privateConstructorUsedError;
  String get status => throw _privateConstructorUsedError;
  String get ip => throw _privateConstructorUsedError;
  String get serverAdd => throw _privateConstructorUsedError;
  String get dns1 => throw _privateConstructorUsedError;
  String get dns2 => throw _privateConstructorUsedError;
  String get bssid => throw _privateConstructorUsedError;
  String get linkspeed => throw _privateConstructorUsedError;
  String get levels => throw _privateConstructorUsedError;
  String get channelwidth => throw _privateConstructorUsedError;
  String get frequency => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $WifiInfoStateDataCopyWith<WifiInfoStateData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WifiInfoStateDataCopyWith<$Res> {
  factory $WifiInfoStateDataCopyWith(
          WifiInfoStateData value, $Res Function(WifiInfoStateData) then) =
      _$WifiInfoStateDataCopyWithImpl<$Res, WifiInfoStateData>;
  @useResult
  $Res call(
      {String ssid,
      String status,
      String ip,
      String serverAdd,
      String dns1,
      String dns2,
      String bssid,
      String linkspeed,
      String levels,
      String channelwidth,
      String frequency});
}

/// @nodoc
class _$WifiInfoStateDataCopyWithImpl<$Res, $Val extends WifiInfoStateData>
    implements $WifiInfoStateDataCopyWith<$Res> {
  _$WifiInfoStateDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ssid = null,
    Object? status = null,
    Object? ip = null,
    Object? serverAdd = null,
    Object? dns1 = null,
    Object? dns2 = null,
    Object? bssid = null,
    Object? linkspeed = null,
    Object? levels = null,
    Object? channelwidth = null,
    Object? frequency = null,
  }) {
    return _then(_value.copyWith(
      ssid: null == ssid
          ? _value.ssid
          : ssid // ignore: cast_nullable_to_non_nullable
              as String,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as String,
      ip: null == ip
          ? _value.ip
          : ip // ignore: cast_nullable_to_non_nullable
              as String,
      serverAdd: null == serverAdd
          ? _value.serverAdd
          : serverAdd // ignore: cast_nullable_to_non_nullable
              as String,
      dns1: null == dns1
          ? _value.dns1
          : dns1 // ignore: cast_nullable_to_non_nullable
              as String,
      dns2: null == dns2
          ? _value.dns2
          : dns2 // ignore: cast_nullable_to_non_nullable
              as String,
      bssid: null == bssid
          ? _value.bssid
          : bssid // ignore: cast_nullable_to_non_nullable
              as String,
      linkspeed: null == linkspeed
          ? _value.linkspeed
          : linkspeed // ignore: cast_nullable_to_non_nullable
              as String,
      levels: null == levels
          ? _value.levels
          : levels // ignore: cast_nullable_to_non_nullable
              as String,
      channelwidth: null == channelwidth
          ? _value.channelwidth
          : channelwidth // ignore: cast_nullable_to_non_nullable
              as String,
      frequency: null == frequency
          ? _value.frequency
          : frequency // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$WifiInfoStateDataImplCopyWith<$Res>
    implements $WifiInfoStateDataCopyWith<$Res> {
  factory _$$WifiInfoStateDataImplCopyWith(_$WifiInfoStateDataImpl value,
          $Res Function(_$WifiInfoStateDataImpl) then) =
      __$$WifiInfoStateDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String ssid,
      String status,
      String ip,
      String serverAdd,
      String dns1,
      String dns2,
      String bssid,
      String linkspeed,
      String levels,
      String channelwidth,
      String frequency});
}

/// @nodoc
class __$$WifiInfoStateDataImplCopyWithImpl<$Res>
    extends _$WifiInfoStateDataCopyWithImpl<$Res, _$WifiInfoStateDataImpl>
    implements _$$WifiInfoStateDataImplCopyWith<$Res> {
  __$$WifiInfoStateDataImplCopyWithImpl(_$WifiInfoStateDataImpl _value,
      $Res Function(_$WifiInfoStateDataImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ssid = null,
    Object? status = null,
    Object? ip = null,
    Object? serverAdd = null,
    Object? dns1 = null,
    Object? dns2 = null,
    Object? bssid = null,
    Object? linkspeed = null,
    Object? levels = null,
    Object? channelwidth = null,
    Object? frequency = null,
  }) {
    return _then(_$WifiInfoStateDataImpl(
      null == ssid
          ? _value.ssid
          : ssid // ignore: cast_nullable_to_non_nullable
              as String,
      null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as String,
      null == ip
          ? _value.ip
          : ip // ignore: cast_nullable_to_non_nullable
              as String,
      null == serverAdd
          ? _value.serverAdd
          : serverAdd // ignore: cast_nullable_to_non_nullable
              as String,
      null == dns1
          ? _value.dns1
          : dns1 // ignore: cast_nullable_to_non_nullable
              as String,
      null == dns2
          ? _value.dns2
          : dns2 // ignore: cast_nullable_to_non_nullable
              as String,
      null == bssid
          ? _value.bssid
          : bssid // ignore: cast_nullable_to_non_nullable
              as String,
      null == linkspeed
          ? _value.linkspeed
          : linkspeed // ignore: cast_nullable_to_non_nullable
              as String,
      null == levels
          ? _value.levels
          : levels // ignore: cast_nullable_to_non_nullable
              as String,
      null == channelwidth
          ? _value.channelwidth
          : channelwidth // ignore: cast_nullable_to_non_nullable
              as String,
      null == frequency
          ? _value.frequency
          : frequency // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$WifiInfoStateDataImpl
    with DiagnosticableTreeMixin
    implements _WifiInfoStateData {
  const _$WifiInfoStateDataImpl(
      [this.ssid = "",
      this.status = "",
      this.ip = "",
      this.serverAdd = "",
      this.dns1 = "",
      this.dns2 = "",
      this.bssid = "",
      this.linkspeed = "",
      this.levels = "",
      this.channelwidth = "",
      this.frequency = ""]);

  @override
  @JsonKey()
  final String ssid;
  @override
  @JsonKey()
  final String status;
  @override
  @JsonKey()
  final String ip;
  @override
  @JsonKey()
  final String serverAdd;
  @override
  @JsonKey()
  final String dns1;
  @override
  @JsonKey()
  final String dns2;
  @override
  @JsonKey()
  final String bssid;
  @override
  @JsonKey()
  final String linkspeed;
  @override
  @JsonKey()
  final String levels;
  @override
  @JsonKey()
  final String channelwidth;
  @override
  @JsonKey()
  final String frequency;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'WifiInfoStateData(ssid: $ssid, status: $status, ip: $ip, serverAdd: $serverAdd, dns1: $dns1, dns2: $dns2, bssid: $bssid, linkspeed: $linkspeed, levels: $levels, channelwidth: $channelwidth, frequency: $frequency)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'WifiInfoStateData'))
      ..add(DiagnosticsProperty('ssid', ssid))
      ..add(DiagnosticsProperty('status', status))
      ..add(DiagnosticsProperty('ip', ip))
      ..add(DiagnosticsProperty('serverAdd', serverAdd))
      ..add(DiagnosticsProperty('dns1', dns1))
      ..add(DiagnosticsProperty('dns2', dns2))
      ..add(DiagnosticsProperty('bssid', bssid))
      ..add(DiagnosticsProperty('linkspeed', linkspeed))
      ..add(DiagnosticsProperty('levels', levels))
      ..add(DiagnosticsProperty('channelwidth', channelwidth))
      ..add(DiagnosticsProperty('frequency', frequency));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WifiInfoStateDataImpl &&
            (identical(other.ssid, ssid) || other.ssid == ssid) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.ip, ip) || other.ip == ip) &&
            (identical(other.serverAdd, serverAdd) ||
                other.serverAdd == serverAdd) &&
            (identical(other.dns1, dns1) || other.dns1 == dns1) &&
            (identical(other.dns2, dns2) || other.dns2 == dns2) &&
            (identical(other.bssid, bssid) || other.bssid == bssid) &&
            (identical(other.linkspeed, linkspeed) ||
                other.linkspeed == linkspeed) &&
            (identical(other.levels, levels) || other.levels == levels) &&
            (identical(other.channelwidth, channelwidth) ||
                other.channelwidth == channelwidth) &&
            (identical(other.frequency, frequency) ||
                other.frequency == frequency));
  }

  @override
  int get hashCode => Object.hash(runtimeType, ssid, status, ip, serverAdd,
      dns1, dns2, bssid, linkspeed, levels, channelwidth, frequency);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WifiInfoStateDataImplCopyWith<_$WifiInfoStateDataImpl> get copyWith =>
      __$$WifiInfoStateDataImplCopyWithImpl<_$WifiInfoStateDataImpl>(
          this, _$identity);
}

abstract class _WifiInfoStateData implements WifiInfoStateData {
  const factory _WifiInfoStateData(
      [final String ssid,
      final String status,
      final String ip,
      final String serverAdd,
      final String dns1,
      final String dns2,
      final String bssid,
      final String linkspeed,
      final String levels,
      final String channelwidth,
      final String frequency]) = _$WifiInfoStateDataImpl;

  @override
  String get ssid;
  @override
  String get status;
  @override
  String get ip;
  @override
  String get serverAdd;
  @override
  String get dns1;
  @override
  String get dns2;
  @override
  String get bssid;
  @override
  String get linkspeed;
  @override
  String get levels;
  @override
  String get channelwidth;
  @override
  String get frequency;
  @override
  @JsonKey(ignore: true)
  _$$WifiInfoStateDataImplCopyWith<_$WifiInfoStateDataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$WifiInfoState {
  WifiInfoStateData? get data => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(WifiInfoStateData? data) initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(WifiInfoStateData? data)? initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(WifiInfoStateData? data)? initial,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $WifiInfoStateCopyWith<WifiInfoState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WifiInfoStateCopyWith<$Res> {
  factory $WifiInfoStateCopyWith(
          WifiInfoState value, $Res Function(WifiInfoState) then) =
      _$WifiInfoStateCopyWithImpl<$Res, WifiInfoState>;
  @useResult
  $Res call({WifiInfoStateData? data});

  $WifiInfoStateDataCopyWith<$Res>? get data;
}

/// @nodoc
class _$WifiInfoStateCopyWithImpl<$Res, $Val extends WifiInfoState>
    implements $WifiInfoStateCopyWith<$Res> {
  _$WifiInfoStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = freezed,
  }) {
    return _then(_value.copyWith(
      data: freezed == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as WifiInfoStateData?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $WifiInfoStateDataCopyWith<$Res>? get data {
    if (_value.data == null) {
      return null;
    }

    return $WifiInfoStateDataCopyWith<$Res>(_value.data!, (value) {
      return _then(_value.copyWith(data: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res>
    implements $WifiInfoStateCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({WifiInfoStateData? data});

  @override
  $WifiInfoStateDataCopyWith<$Res>? get data;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$WifiInfoStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = freezed,
  }) {
    return _then(_$InitialImpl(
      data: freezed == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as WifiInfoStateData?,
    ));
  }
}

/// @nodoc

class _$InitialImpl with DiagnosticableTreeMixin implements Initial {
  const _$InitialImpl({this.data});

  @override
  final WifiInfoStateData? data;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'WifiInfoState.initial(data: $data)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'WifiInfoState.initial'))
      ..add(DiagnosticsProperty('data', data));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InitialImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InitialImplCopyWith<_$InitialImpl> get copyWith =>
      __$$InitialImplCopyWithImpl<_$InitialImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(WifiInfoStateData? data) initial,
  }) {
    return initial(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(WifiInfoStateData? data)? initial,
  }) {
    return initial?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(WifiInfoStateData? data)? initial,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class Initial implements WifiInfoState {
  const factory Initial({final WifiInfoStateData? data}) = _$InitialImpl;

  @override
  WifiInfoStateData? get data;
  @override
  @JsonKey(ignore: true)
  _$$InitialImplCopyWith<_$InitialImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
